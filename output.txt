
 File path: ./Cargo.toml 
 
[package]
name = "compiler"
version = "0.1.0"
edition = "2021"


 File path: ./src/main.rs 
 
use codegen::BytecodeGenerator;
pub mod log;
use ir::IrGenerator;
use lexer::Lexer;
use log::set_log_level;
use parser::Parser;
use semantic::{Context, TypeChecker};
use std::{fs::File, io::Read};
use vm::VM;

pub use crate::log::LogLevel;
pub use crate::log::{debug, error, info, trace, warn};
mod ast_node;
mod codegen;
mod ir;
mod lexer;
mod parser;
mod semantic;
mod tokens;
mod vm;
//
fn main() {
    set_log_level(LogLevel::Debug);
    let mut file = File::open("bob.deez").unwrap();

    let mut buf = String::new();

    file.read_to_string(&mut buf).unwrap();

    let mut lexer = Lexer::new(&buf);

    let tokens = lexer.tokenize();

    let mut parser = Parser::new(tokens);
    let stmts = parser.parse().expect("Parser sais:");

    let mut semantic_checker = TypeChecker::new();

    let mut ctx = Context::new();
    semantic_checker
        .check(&mut ctx, &stmts)
        .expect("Type checker said:");

    let mut ir = IrGenerator::new();

    let ir_program = ir.generate(&stmts);

    let mut codegen = BytecodeGenerator::new();

    let bytecode = codegen.generate(&ir_program);

    let mut vm = VM::new(&bytecode);

    let _ = vm.execute(&bytecode);
    ()
}

 File path: ./src/vm.rs 
 
use crate::ast_node::LiteralValue;
use crate::codegen::{Bytecode, BytecodeOp};
use crate::{debug, error, info, trace};

pub struct VM {
    constants: Vec<LiteralValue>,
    variables: Vec<LiteralValue>,
    stack: Vec<LiteralValue>,
    ip: usize,
}

impl VM {
    pub fn new(bytecode: &Bytecode) -> Self {
        info!("VM", "Creating new VM instance");
        VM {
            constants: bytecode.constants.clone(),
            variables: vec![LiteralValue::Number(0.); bytecode.variables.len()],
            stack: Vec::with_capacity(256),
            ip: 0,
        }
    }

    fn format_instruction(&self, bytecode: &Bytecode) -> String {
        if self.ip >= bytecode.instructions.len() {
            return "END".to_string();
        }

        let (op, operand) = bytecode.instructions[self.ip];
        match operand {
            Some(val) => format!("{:?}({})", op, val),
            None => format!("{:?}", op),
        }
    }

    pub fn execute(&mut self, bytecode: &Bytecode) -> Result<LiteralValue, String> {
        info!("VM", "Starting bytecode execution");

        while self.ip < bytecode.instructions.len() {
            trace!("VM", "Stack: {:?}", &self.stack);
            trace!(
                "VM",
                "IP: {}, Instruction: {}",
                self.ip,
                self.format_instruction(bytecode)
            );

            let (op, operand) = bytecode.instructions[self.ip];

            match op {
                BytecodeOp::LoadConst => {
                    let idx = operand.unwrap();
                    debug!("VM", "Loading constant[{}]: {:?}", idx, self.constants[idx]);
                    self.stack.push(self.constants[idx].clone());
                }
                BytecodeOp::Echo => {
                    let value = self.stack.pop().unwrap();
                    println!("{value}")
                }
                BytecodeOp::LoadVar => {
                    let idx = operand.unwrap();
                    debug!("VM", "Loading variable[{}]: {:?}", idx, self.variables[idx]);
                    self.stack.push(self.variables[idx].clone());
                }
                BytecodeOp::StoreVar => {
                    let idx = operand.unwrap();
                    let value = self.stack.pop().unwrap();
                    debug!("VM", "Storing {:?} in variable[{}]", value, idx);
                    self.variables[idx] = value;
                }
                BytecodeOp::Add => {
                    let b = self.stack.pop().unwrap();
                    let a = self.stack.pop().unwrap();
                    debug!("VM", "Add: {:?} + {:?}", a, b);

                    match (a, b) {
                        (LiteralValue::Number(a), LiteralValue::Number(b)) => {
                            let result = a + b;
                            debug!("VM", "Add result: {}", result);
                            self.stack.push(LiteralValue::Number(result))
                        }
                        _ => {
                            error!("VM", "Type error: Cannot add non-numeric values");
                        }
                    }
                }
                BytecodeOp::Subtract => {
                    let b = self.stack.pop().unwrap();
                    let a = self.stack.pop().unwrap();
                    debug!("VM", "Subtract: {:?} - {:?}", a, b);

                    match (a, b) {
                        (LiteralValue::Number(a), LiteralValue::Number(b)) => {
                            let result = a - b;
                            debug!("VM", "Subtract result: {}", result);
                            self.stack.push(LiteralValue::Number(result))
                        }
                        _ => {
                            error!("VM", "Type error: Cannot subtract non-numeric values");
                        }
                    }
                }
                BytecodeOp::Multiply => {
                    let b = self.stack.pop().unwrap();
                    let a = self.stack.pop().unwrap();
                    debug!("VM", "Multiply: {:?} * {:?}", a, b);

                    match (a, b) {
                        (LiteralValue::Number(a), LiteralValue::Number(b)) => {
                            let result = a * b;
                            debug!("VM", "Multiply result: {}", result);
                            self.stack.push(LiteralValue::Number(result))
                        }
                        _ => {
                            error!("VM", "Type error: Cannot multiply non-numeric values");
                        }
                    }
                }
                BytecodeOp::Divide => {
                    let b = self.stack.pop().unwrap();
                    let a = self.stack.pop().unwrap();
                    debug!("VM", "Divide: {:?} / {:?}", a, b);

                    if b == LiteralValue::Number(0.0) {
                        error!("VM", "Runtime error: Division by zero");
                        return Err("Division by zero".to_string());
                    }

                    match (a, b) {
                        (LiteralValue::Number(a), LiteralValue::Number(b)) => {
                            let result = a / b;
                            debug!("VM", "Divide result: {}", result);
                            self.stack.push(LiteralValue::Number(result))
                        }
                        _ => {
                            error!("VM", "Type error: Cannot divide non-numeric values");
                        }
                    }
                }
                BytecodeOp::Negate => {
                    let a = self.stack.pop().unwrap();
                    debug!("VM", "Negate: {:?}", a);

                    if let LiteralValue::Number(a) = a {
                        let result = -a;
                        debug!("VM", "Negate result: {}", result);
                        self.stack.push(LiteralValue::Number(result));
                    } else {
                        error!("VM", "Type error: Cannot negate non-numeric value");
                    }
                }
                BytecodeOp::Return => {
                    let result = if self.stack.is_empty() {
                        debug!("VM", "Return with empty stack, defaulting to 0");
                        LiteralValue::Number(0.)
                    } else {
                        let value = self.stack.pop().unwrap();
                        debug!("VM", "Return value: {:?}", value);
                        value
                    };

                    info!("VM", "Execution completed with result: {:?}", result);
                    return Ok(result);
                }
                BytecodeOp::Jump => {
                    let target = operand.unwrap();
                    debug!("VM", "Jump from {} to {}", self.ip, target);
                    self.ip = target;
                    continue; // Skip the ip increment at the end of the loop
                }
                BytecodeOp::Equals => {
                    let right_val = self.stack.pop().unwrap();
                    let left_val = self.stack.pop().unwrap();
                    debug!("VM", "Equals: {:?} == {:?}", left_val, right_val);

                    let result = left_val == right_val;
                    debug!("VM", "Equals result: {}", result);
                    self.stack.push(LiteralValue::Bool(result));
                }
                BytecodeOp::NotEquals => {
                    let right_val = self.stack.pop().unwrap();
                    let left_val = self.stack.pop().unwrap();
                    debug!("VM", "NotEquals: {:?} != {:?}", left_val, right_val);

                    let result = left_val != right_val;
                    debug!("VM", "NotEquals result: {}", result);
                    self.stack.push(LiteralValue::Bool(result));
                }
                BytecodeOp::Greater => {
                    let right_val = self.stack.pop().unwrap();
                    let left_val = self.stack.pop().unwrap();
                    debug!("VM", "Greater: {:?} > {:?}", left_val, right_val);

                    match left_val > right_val {
                        true => {
                            debug!("VM", "Greater result: true");
                            self.stack.push(LiteralValue::Bool(true));
                        }
                        false => {
                            debug!("VM", "Greater result: false");
                            self.stack.push(LiteralValue::Bool(false));
                        }
                    }
                }
                BytecodeOp::Less => {
                    let right_val = self.stack.pop().unwrap();
                    let left_val = self.stack.pop().unwrap();
                    debug!("VM", "Less: {:?} < {:?}", left_val, right_val);

                    match left_val < right_val {
                        true => {
                            debug!("VM", "Less result: true");
                            self.stack.push(LiteralValue::Bool(true));
                        }
                        false => {
                            debug!("VM", "Less result: false");
                            self.stack.push(LiteralValue::Bool(false));
                        }
                    }
                }
                BytecodeOp::GreaterOrEq => {
                    let right_val = self.stack.pop().unwrap();
                    let left_val = self.stack.pop().unwrap();
                    debug!("VM", "GreaterOrEq: {:?} >= {:?}", left_val, right_val);

                    match left_val >= right_val {
                        true => {
                            debug!("VM", "GreaterOrEq result: true");
                            self.stack.push(LiteralValue::Bool(true));
                        }
                        false => {
                            debug!("VM", "GreaterOrEq result: false");
                            self.stack.push(LiteralValue::Bool(false));
                        }
                    }
                }
                BytecodeOp::LessOrEq => {
                    let right_val = self.stack.pop().unwrap();
                    let left_val = self.stack.pop().unwrap();
                    debug!("VM", "LessOrEq: {:?} <= {:?}", left_val, right_val);

                    match left_val <= right_val {
                        true => {
                            debug!("VM", "LessOrEq result: true");
                            self.stack.push(LiteralValue::Bool(true));
                        }
                        false => {
                            debug!("VM", "LessOrEq result: false");
                            self.stack.push(LiteralValue::Bool(false));
                        }
                    }
                }
                BytecodeOp::JumpIfFalse => {
                    let cond = self.stack.pop().unwrap();
                    let target = operand.unwrap();

                    if let LiteralValue::Bool(condition) = cond {
                        debug!(
                            "VM",
                            "JumpIfFalse condition: {}, target: {}", condition, target
                        );

                        if !condition {
                            debug!("VM", "Condition is false, jumping to {}", target);
                            self.ip = target;
                            continue; // Skip the ip increment at the end of the loop
                        } else {
                            debug!("VM", "Condition is true, not jumping");
                        }
                    } else {
                        error!(
                            "VM",
                            "Type error: JumpIfFalse expected Bool, got {:?}", cond
                        );
                    }
                }
            }

            self.ip += 1;
        }

        // If we reach here, there was no return instruction
        let result = if self.stack.is_empty() {
            debug!(
                "VM",
                "Execution completed with empty stack, defaulting to 0"
            );
            LiteralValue::Number(0.)
        } else {
            let value = self.stack.pop().unwrap();
            debug!(
                "VM",
                "Execution completed, returning top of stack: {:?}", value
            );
            value
        };

        info!("VM", "Execution completed with result: {:?}", result);
        Ok(result)
    }
}

 File path: ./src/ir.rs 
 
use crate::{
    ast_node::{Expr, LiteralValue, Stmt},
    tokens::TokenType,
};

#[derive(Debug, Clone)]
pub enum OpCode {
    LoadConst,
    LoadVar,
    StoreVar,

    Add,
    Subtract,
    Multiply,
    Divide,

    Equals,
    NotEquals,
    Greater,
    Less,
    GreaterOrEq,
    LessOrEq,

    Negate,

    Echo,

    Jump,
    JumpIfFalse,
}

#[derive(Debug, Clone)]
pub struct Instruction {
    pub op: OpCode,
    pub operands: Vec<Operand>,
}

#[derive(Debug, Clone)]
pub enum Operand {
    Register(usize),
    Immediate(LiteralValue),
    Variable(String),
}

#[derive(Debug)]
pub struct IrProgram {
    pub instructions: Vec<Instruction>,
}

pub struct IrGenerator {
    instructions: Vec<Instruction>,
    temp_counter: usize,
}

impl IrGenerator {
    pub fn new() -> Self {
        IrGenerator {
            instructions: Vec::new(),
            temp_counter: 0,
        }
    }

    pub fn generate(&mut self, statements: &[Stmt]) -> IrProgram {
        for stmt in statements {
            self.generate_statement(stmt);
        }

        IrProgram {
            instructions: self.instructions.clone(),
        }
    }

    fn generate_statement(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Expression { expression } => {
                self.generate_expression(expression);
            }
            Stmt::FunctionDeclaration { args, name, body } => {}
            Stmt::Echo { expression } => {
                let expr_temp = self.generate_expression(expression);

                self.emit(OpCode::Echo, vec![Operand::Register(expr_temp)]);
            }
            Stmt::Let { name, initializer } => {
                if let Some(init) = initializer {
                    let temp = self.generate_expression(init);

                    if let TokenType::Identifier(name_str) = &name.token_type {
                        self.emit(
                            OpCode::StoreVar,
                            vec![Operand::Variable(name_str.clone()), Operand::Register(temp)],
                        );
                    }
                }
            }
            Stmt::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let condition_temp = self.generate_expression(condition);
                let jump_if_false_idx = self.instructions.len();
                self.emit(
                    OpCode::JumpIfFalse,
                    vec![
                        Operand::Register(condition_temp),
                        Operand::Immediate(LiteralValue::Number(0.)),
                    ],
                );

                self.generate_statement(then_branch);
                if let Some(else_branch) = else_branch {
                    let jump_end_idx = self.instructions.len();
                    self.emit(
                        OpCode::Jump,
                        vec![Operand::Immediate(LiteralValue::Number(0.0))],
                    );

                    let else_start_idx = self.instructions.len();

                    if let Operand::Immediate(LiteralValue::Number(ref mut value)) =
                        self.instructions[jump_if_false_idx].operands[1]
                    {
                        *value = else_start_idx as f64;
                    }

                    self.generate_statement(else_branch);

                    let end_idx = self.instructions.len();
                    if let Operand::Immediate(LiteralValue::Number(ref mut value)) =
                        self.instructions[jump_end_idx].operands[0]
                    {
                        *value = end_idx as f64;
                    }
                } else {
                    let end_idx = self.instructions.len();
                    if let Operand::Immediate(LiteralValue::Number(ref mut value)) =
                        self.instructions[jump_if_false_idx].operands[1]
                    {
                        *value = end_idx as f64;
                    }
                }
            }
            Stmt::Block { statements } => {
                for st in statements {
                    self.generate_statement(st);
                }
            }
        }
    }

    fn generate_expression(&mut self, expr: &Expr) -> usize {
        match expr {
            Expr::Binary {
                left,
                operator,
                right,
            } => {
                let left_temp = self.generate_expression(left);
                let right_temp = self.generate_expression(right);
                let result_temp = self.new_temp();

                let op = match operator.token_type {
                    TokenType::Plus => OpCode::Add,
                    TokenType::Minus => OpCode::Subtract,
                    TokenType::Star => OpCode::Multiply,
                    TokenType::Slash => OpCode::Divide,
                    TokenType::EqualEqual => OpCode::Equals,
                    TokenType::BangEqual => OpCode::NotEquals,
                    TokenType::Greater => OpCode::Greater,
                    TokenType::GreaterOrEq => OpCode::GreaterOrEq,
                    TokenType::Less => OpCode::Less,
                    TokenType::LessOrEq => OpCode::LessOrEq,
                    _ => panic!("Unexpected binary operator"),
                };

                self.emit(
                    op,
                    vec![
                        Operand::Register(result_temp),
                        Operand::Register(left_temp),
                        Operand::Register(right_temp),
                    ],
                );

                result_temp
            }
            Expr::Unary { operator, right } => {
                let right_temp = self.generate_expression(right);
                let result_temp = self.new_temp();

                match operator.token_type {
                    TokenType::Minus => {
                        self.emit(
                            OpCode::Negate,
                            vec![
                                Operand::Register(result_temp),
                                Operand::Register(right_temp),
                            ],
                        );
                    }
                    _ => panic!("Unexpected unary operator"),
                }

                result_temp
            }
            Expr::Grouping { expression } => self.generate_expression(expression),
            Expr::Literal { value } => {
                let result_temp = self.new_temp();

                match value {
                    LiteralValue::Number(_) => {
                        self.emit(
                            OpCode::LoadConst,
                            vec![
                                Operand::Register(result_temp),
                                Operand::Immediate(value.clone()),
                            ],
                        );
                    }
                    LiteralValue::String(_) => {
                        self.emit(
                            OpCode::LoadConst,
                            vec![
                                Operand::Register(result_temp),
                                Operand::Immediate(value.clone()),
                            ],
                        );
                    }
                    LiteralValue::Bool(_) => {
                        self.emit(
                            OpCode::LoadConst,
                            vec![
                                Operand::Register(result_temp),
                                Operand::Immediate(value.clone()),
                            ],
                        );
                    }
                    _ => panic!("Unexpected literal type"),
                }

                result_temp
            }
            Expr::Variable { name } => {
                let result_temp = self.new_temp();

                if let TokenType::Identifier(name_str) = &name.token_type {
                    self.emit(
                        OpCode::LoadVar,
                        vec![
                            Operand::Register(result_temp),
                            Operand::Variable(name_str.clone()),
                        ],
                    );
                }

                result_temp
            }
        }
    }

    fn emit(&mut self, op: OpCode, operands: Vec<Operand>) {
        self.instructions.push(Instruction { op, operands });
    }

    fn new_temp(&mut self) -> usize {
        let temp = self.temp_counter;
        self.temp_counter += 1;
        temp
    }
}

 File path: ./src/semantic.rs 
 
use std::{collections::HashMap, ops::Deref};

use crate::{
    ast_node::{Expr, LiteralValue, Stmt},
    tokens::TokenType,
};

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Number,
    Bool,
    Nil,
    String,
    Unknown,
}

#[derive(Clone)]
pub struct Context {
    values: HashMap<String, Type>,
    parent_context: Option<Box<Context>>,
}

impl Context {
    pub fn new() -> Self {
        Context {
            values: HashMap::new(),
            parent_context: None,
        }
    }

    pub fn with_parent(ctx: Context) -> Self {
        Context {
            values: HashMap::new(),
            parent_context: Some(Box::new(ctx)),
        }
    }

    /// defines a variable with name and type;
    pub fn define(&mut self, name: &str, value_type: Type) {
        self.values.insert(name.to_string(), value_type);
    }

    // gets a type of variable by its name recursively to higher env;
    pub fn get(&self, name: &str) -> Option<Type> {
        if let Some(value_type) = self.values.get(name) {
            return Some(value_type.clone());
        }

        if let Some(enclosing) = &self.parent_context {
            return enclosing.get(name);
        }

        None
    }
}

pub struct TypeChecker {}

impl TypeChecker {
    pub fn new() -> Self {
        TypeChecker {}
    }

    pub fn check(&mut self, ctx: &mut Context, statements: &[Stmt]) -> Result<(), String> {
        for statement in statements {
            self.check_statement(ctx, statement)?;
        }

        Ok(())
    }

    fn check_statement(&mut self, context: &mut Context, stmt: &Stmt) -> Result<(), String> {
        match stmt {
            Stmt::Expression { expression } => {
                self.check_expression(context, expression)?;
                Ok(())
            }
            Stmt::Let { name, initializer } => {
                let var_type = if let Some(init) = initializer {
                    self.check_expression(context, init)?
                } else {
                    Type::Nil
                };

                if let TokenType::Identifier(name_str) = &name.token_type {
                    context.define(name_str, var_type);
                    Ok(())
                } else {
                    Err("Expected identifier".to_string())
                }
            }
            Stmt::FunctionDeclaration { args, name, body } => Ok(()),
            Stmt::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let condition_type = self.check_expression(context, condition)?;

                if condition_type != Type::Bool {
                    return Err("Condition must be of type `bool`".into());
                }

                let mut then_branch_ctx = Context::with_parent(context.clone());
                if let Stmt::Block { statements } = then_branch.deref() {
                    self.check(&mut then_branch_ctx, &statements)?;
                }
                let mut else_branch_ctx = Context::with_parent(context.clone());
                if let Some(stmt) = else_branch {
                    if let Stmt::Block { statements } = stmt.deref() {
                        self.check(&mut else_branch_ctx, &statements)?;
                    }
                }

                Ok(())
            }
            Stmt::Echo { .. } => Ok(()),
            Stmt::Block { statements } => Ok(statements
                .iter()
                .try_for_each(|s| self.check_statement(context, s))?),
        }
    }

    /// this returns type of expression;
    fn check_expression(&mut self, ctx: &mut Context, expr: &Expr) -> Result<Type, String> {
        match expr {
            Expr::Binary {
                left,
                operator,
                right,
            } => {
                let left_type = self.check_expression(ctx, left)?;
                let right_type = self.check_expression(ctx, right)?;

                match operator.token_type {
                    TokenType::Plus | TokenType::Minus | TokenType::Star | TokenType::Slash => {
                        if left_type != Type::Number || right_type != Type::Number {
                            return Err(format!(
                                "Operands must be numbers, got {:?} and {:?}",
                                left_type, right_type
                            ));
                        }

                        Ok(Type::Number)
                    }
                    TokenType::BangEqual | TokenType::EqualEqual => {
                        if left_type != right_type {
                            return Err(format!(
                                "Operands must be of the same type, got {:?} and {:?}",
                                left_type, right_type
                            ));
                        } else {
                            Ok(Type::Bool)
                        }
                    }
                    TokenType::Greater
                    | TokenType::Less
                    | TokenType::GreaterOrEq
                    | TokenType::LessOrEq => {
                        if left_type != Type::Number || right_type != Type::Number {
                            return Err(format!(
                                "Comparison operators require number operands, got {:?} and {:?}",
                                left_type, right_type
                            ));
                        }

                        // All comparison operators yield a boolean result
                        Ok(Type::Bool)
                    }
                    _ => Err(format!("Unknown binary operator: {:?}", operator)),
                }
            }
            Expr::Unary { operator, right } => {
                let right_type = self.check_expression(ctx, right)?;

                match operator.token_type {
                    TokenType::Minus => {
                        if right_type != Type::Number {
                            return Err(format!("Operand must be a number, got {:?}", right_type));
                        }

                        Ok(Type::Number)
                    }
                    _ => Err(format!("Unknown unary operator: {:?}", operator)),
                }
            }
            Expr::Grouping { expression } => self.check_expression(ctx, expression),
            Expr::Literal { value } => match value {
                LiteralValue::Number(_) => Ok(Type::Number),
                LiteralValue::Bool(_) => Ok(Type::Bool),
                LiteralValue::Nil => Ok(Type::Nil),
                LiteralValue::String(_) => Ok(Type::String),
            },
            Expr::Variable { name } => {
                if let TokenType::Identifier(name_str) = &name.token_type {
                    if let Some(var_type) = ctx.get(name_str) {
                        Ok(var_type)
                    } else {
                        Err(format!("Undefined variable '{}'", name_str))
                    }
                } else {
                    Err("Expected identifier".to_string())
                }
            }
        }
    }
}

 File path: ./src/codegen.rs 
 
use crate::{
    ast_node::LiteralValue,
    ir::{Instruction, IrProgram, OpCode, Operand},
};

#[derive(Debug, Clone, Copy)]
pub enum BytecodeOp {
    LoadConst,
    LoadVar,
    StoreVar,
    Add,
    Subtract,
    Multiply,
    Divide,
    Negate,
    Echo,
    Equals,
    NotEquals,
    Return,

    Greater,
    Less,
    GreaterOrEq,
    LessOrEq,
    JumpIfFalse,
    Jump,
}

#[derive(Debug)]
pub struct Bytecode {
    pub constants: Vec<LiteralValue>,
    pub variables: Vec<String>,
    pub instructions: Vec<(BytecodeOp, Option<usize>)>,
}

pub struct BytecodeGenerator {
    constants: Vec<LiteralValue>,
    variables: Vec<String>,
    instructions: Vec<(BytecodeOp, Option<usize>)>,
}

impl BytecodeGenerator {
    pub fn new() -> Self {
        BytecodeGenerator {
            constants: Vec::new(),
            variables: Vec::new(),
            instructions: Vec::new(),
        }
    }

    pub fn generate(&mut self, ir: &IrProgram) -> Bytecode {
        for instruction in &ir.instructions {
            self.generate_instruction(instruction);
        }

        // Add a return instruction at the end
        self.emit(BytecodeOp::Return, None);

        Bytecode {
            constants: self.constants.clone(),
            variables: self.variables.clone(),
            instructions: self.instructions.clone(),
        }
    }

    fn generate_instruction(&mut self, instruction: &Instruction) {
        match instruction.op {
            OpCode::LoadConst => {
                if let Operand::Immediate(value) = &instruction.operands[1] {
                    let const_idx = self.add_constant(value.clone());
                    self.emit(BytecodeOp::LoadConst, Some(const_idx));
                }
            }

            OpCode::Equals => {
                self.emit(BytecodeOp::Equals, None);
            }

            OpCode::LessOrEq => {
                self.emit(BytecodeOp::LessOrEq, None);
            }

            OpCode::Less => {
                self.emit(BytecodeOp::Less, None);
            }

            OpCode::GreaterOrEq => {
                self.emit(BytecodeOp::GreaterOrEq, None);
            }

            OpCode::Greater => {
                self.emit(BytecodeOp::Greater, None);
            }
            OpCode::NotEquals => {
                self.emit(BytecodeOp::NotEquals, None);
            }
            OpCode::Echo => self.emit(BytecodeOp::Echo, None),

            OpCode::LoadVar => {
                if let Operand::Variable(ref name) = instruction.operands[1] {
                    let var_idx = self.add_variable(name);
                    self.emit(BytecodeOp::LoadVar, Some(var_idx));
                }
            }
            OpCode::StoreVar => {
                if let Operand::Variable(ref name) = instruction.operands[0] {
                    let var_idx = self.add_variable(name);
                    self.emit(BytecodeOp::StoreVar, Some(var_idx));
                }
            }
            OpCode::Jump => {
                if let Operand::Immediate(LiteralValue::Number(target_addr)) =
                    instruction.operands[0]
                {
                    self.emit(BytecodeOp::Jump, Some(target_addr as usize));
                }
            }
            OpCode::JumpIfFalse => {
                if let Operand::Immediate(LiteralValue::Number(target_addr)) =
                    instruction.operands[1]
                {
                    self.emit(BytecodeOp::JumpIfFalse, Some(target_addr as usize));
                }
            }
            OpCode::Add => self.emit(BytecodeOp::Add, None),
            OpCode::Subtract => self.emit(BytecodeOp::Subtract, None),
            OpCode::Multiply => self.emit(BytecodeOp::Multiply, None),
            OpCode::Divide => self.emit(BytecodeOp::Divide, None),
            OpCode::Negate => self.emit(BytecodeOp::Negate, None),
        }
    }

    fn add_constant(&mut self, value: LiteralValue) -> usize {
        if let Some(idx) = self.constants.iter().position(|c| *c == value) {
            return idx;
        }

        let idx = self.constants.len();
        self.constants.push(value);
        idx
    }

    fn add_variable(&mut self, name: &str) -> usize {
        if let Some(idx) = self.variables.iter().position(|v| v == name) {
            return idx;
        }

        let idx = self.variables.len();
        self.variables.push(name.to_string());
        idx
    }

    fn emit(&mut self, op: BytecodeOp, operand: Option<usize>) {
        self.instructions.push((op, operand));
    }
}

 File path: ./src/lexer.rs 
 
use crate::tokens::{Token, TokenType};
use crate::{debug, error, info, trace};

pub struct Lexer {
    input: Vec<char>,
    position: usize,
    line: usize,
    column: usize,
}

impl Lexer {
    pub fn new(source: &str) -> Self {
        info!(
            "Lexer",
            "Creating new lexer instance with {} chars",
            source.len()
        );
        Lexer {
            input: source.chars().collect(),
            position: 0,
            line: 1,
            column: 1,
        }
    }

    pub fn tokenize(&mut self) -> Vec<Token> {
        info!("Lexer", "Starting tokenization");
        let mut tokens = Vec::new();

        while let Some(token) = self.next_token() {
            let token_type = token.token_type.clone();
            debug!(
                "Lexer",
                "Found token: {:?} at line {} column {}",
                token.token_type,
                token.line,
                token.column
            );
            tokens.push(token);
            if TokenType::EOF.eq(&token_type) {
                // if met end of file - finish tokenizing
                info!("Lexer", "Reached EOF, tokenization complete");
                break;
            }
        }

        info!(
            "Lexer",
            "Tokenization complete, found {} tokens",
            tokens.len()
        );
        tokens
    }

    fn next_token(&mut self) -> Option<Token> {
        trace!(
            "Lexer",
            "Looking for next token at position {}",
            self.position
        );
        self.skip_whitespace();

        if self.is_at_end() {
            debug!("Lexer", "Reached end of input");
            return Some(self.make_token(TokenType::EOF));
        }

        // skipped through all the whitespace - start from the first non-whitespace char
        let c = self.advance();
        trace!("Lexer", "Processing character: '{}'", c);

        match c {
            '(' => Some(self.make_token(TokenType::LeftParen)),
            ')' => Some(self.make_token(TokenType::RightParen)),
            '{' => Some(self.make_token(TokenType::LeftBrace)),
            '}' => Some(self.make_token(TokenType::RightBrace)),
            '+' => Some(self.make_token(TokenType::Plus)),
            '-' => Some(self.make_token(TokenType::Minus)),
            '*' => Some(self.make_token(TokenType::Star)),
            '/' => Some(self.make_token(TokenType::Slash)),
            ',' => Some(self.make_token(TokenType::Comma)),
            '!' => {
                let next = self.peek();
                trace!(
                    "Lexer",
                    "Checking if '!' is followed by '=': next = '{}'",
                    next
                );
                if self.match_char('=') {
                    Some(self.make_token(TokenType::BangEqual))
                } else {
                    Some(self.make_token(TokenType::LogicalNot))
                }
            }
            '<' => {
                let next = self.peek();
                trace!(
                    "Lexer",
                    "Checking if '<' is followed by '=': next = '{}'",
                    next
                );
                if self.match_char('=') {
                    Some(self.make_token(TokenType::LessOrEq))
                } else {
                    Some(self.make_token(TokenType::Less))
                }
            }
            '>' => {
                let next = self.peek();
                trace!(
                    "Lexer",
                    "Checking if '>' is followed by '=': next = '{}'",
                    next
                );
                if self.match_char('=') {
                    Some(self.make_token(TokenType::GreaterOrEq))
                } else {
                    Some(self.make_token(TokenType::Greater))
                }
            }

            '=' => {
                let next = self.peek();
                trace!(
                    "Lexer",
                    "Checking if '=' is followed by '=': next = '{}'",
                    next
                );
                if self.match_char('=') {
                    Some(self.make_token(TokenType::EqualEqual))
                } else {
                    Some(self.make_token(TokenType::Equal))
                }
            }

            '"' => Some(self.string()),

            '0'..='9' => {
                self.retreat(); // Go back to reprocess the digit
                Some(self.number())
            }

            'a'..='z' | 'A'..='Z' | '_' => {
                self.retreat(); // Go back to reprocess the letter
                Some(self.identifier())
            }

            _ => {
                error!(
                    "Lexer",
                    "Unexpected character: '{}' at line {} column {}", c, self.line, self.column
                );
                self.next_token()
            }
        }
    }

    fn string(&mut self) -> Token {
        debug!(
            "Lexer",
            "Processing string literal at line {} column {}", self.line, self.column
        );
        let mut contents = String::new();
        let start_line = self.line;
        let start_column = self.column;

        while self.peek() != '\"' && !self.is_at_end() {
            contents.push(self.peek());
            self.advance();
        }

        if self.is_at_end() {
            error!(
                "Lexer",
                "Unterminated string starting at line {} column {}", start_line, start_column
            );
            // We continue despite the error to avoid crashing the lexer
        } else {
            // Consume the closing "
            self.advance();
        }

        debug!("Lexer", "String literal: \"{}\"", contents);

        let token = Token {
            column: start_column,
            line: start_line,
            token_type: TokenType::String(contents),
        };

        token
    }

    fn number(&mut self) -> Token {
        debug!(
            "Lexer",
            "Processing number at line {} column {}", self.line, self.column
        );
        let start_pos = self.position;
        let start_line = self.line;
        let start_column = self.column;

        // loop until number is ended. start_pos -> self.position is the "number"
        while !self.is_at_end() && self.peek().is_digit(10) {
            self.advance();
        }

        // if prev loop stopped because of non-digit - it is probably a decimal ".",  so skip it
        // and go back to number proccessing
        if !self.is_at_end() && self.peek() == '.' && self.peek_next().is_digit(10) {
            trace!("Lexer", "Found decimal point in number");
            self.advance(); // Consume the '.'

            while !self.is_at_end() && self.peek().is_digit(10) {
                self.advance();
            }
        }

        let number_str: String = self.input[start_pos..self.position].iter().collect();
        let value = match number_str.parse::<f64>() {
            Ok(v) => {
                debug!("Lexer", "Parsed number: {}", v);
                v
            }
            Err(e) => {
                error!("Lexer", "Failed to parse number '{}': {}", number_str, e);
                0.0 // Default value to avoid crashing
            }
        };

        Token {
            line: start_line,
            column: start_column,
            token_type: TokenType::Number(value),
        }
    }

    fn identifier(&mut self) -> Token {
        debug!(
            "Lexer",
            "Processing identifier at line {} column {}", self.line, self.column
        );
        let start_pos = self.position;
        let start_line = self.line;
        let start_column = self.column;

        // if this is a variable, that has chars and numbers and _
        while !self.is_at_end() && (self.peek().is_alphanumeric() || self.peek() == '_') {
            self.advance();
        }

        let identifier: String = self.input[start_pos..self.position].iter().collect();
        trace!("Lexer", "Identifier or keyword: '{}'", identifier);

        // Check for keywords
        let token_type = match identifier.as_str() {
            "let" => TokenType::Let,
            "if" => TokenType::If,
            "else" => TokenType::Else,
            "true" => TokenType::Bool(true),
            "false" => TokenType::Bool(false),
            "echo" => TokenType::Echo,
            "fn" => TokenType::FunctionDeclaration,
            _ => TokenType::Identifier(identifier),
        };

        debug!("Lexer", "Identified as: {:?}", token_type);

        Token {
            line: start_line,
            column: start_column,
            token_type,
        }
    }

    // Helper methods
    fn is_at_end(&self) -> bool {
        self.position >= self.input.len()
    }

    fn advance(&mut self) -> char {
        if self.is_at_end() {
            trace!("Lexer", "Attempted to advance past end of input");
            return '\0';
        }

        let c = self.input[self.position];
        self.position += 1;
        self.column += 1;

        if c == '\n' {
            self.line += 1;
            self.column = 1;
            trace!("Lexer", "Advanced to new line {}", self.line);
        }

        c
    }

    fn retreat(&mut self) {
        if self.position > 0 {
            self.position -= 1;
            self.column -= 1;
            trace!(
                "Lexer",
                "Retreated to position {}, column {}",
                self.position,
                self.column
            );
        } else {
            error!("Lexer", "Attempted to retreat before start of input");
        }
    }

    fn peek(&self) -> char {
        if self.is_at_end() {
            '\0'
        } else {
            self.input[self.position]
        }
    }

    fn peek_next(&self) -> char {
        if self.position + 1 >= self.input.len() {
            '\0'
        } else {
            self.input[self.position + 1]
        }
    }

    fn match_char(&mut self, expected: char) -> bool {
        if self.is_at_end() || self.peek() != expected {
            false
        } else {
            self.advance();
            true
        }
    }

    /// Skips all whitespace (' '), tabs ('\t'), empty lines ('\n') and comments
    fn skip_whitespace(&mut self) {
        trace!(
            "Lexer",
            "Skipping whitespace starting at position {}",
            self.position
        );
        let start_pos = self.position;

        while !self.is_at_end() {
            match self.peek() {
                ' ' | '\r' | '\t' => {
                    self.advance();
                }
                '\n' => {
                    self.line += 1;
                    self.column = 1;
                    self.advance();
                }
                // Skip comments
                '/' if self.peek_next() == '/' => {
                    trace!("Lexer", "Skipping comment at line {}", self.line);
                    while !self.is_at_end() && self.peek() != '\n' {
                        self.advance();
                    }
                }
                _ => break,
            }
        }

        if self.position > start_pos {
            trace!(
                "Lexer",
                "Skipped {} whitespace characters",
                self.position - start_pos
            );
        }
    }

    fn make_token(&self, token_type: TokenType) -> Token {
        trace!(
            "Lexer",
            "Creating token: {:?} at line {} column {}",
            token_type,
            self.line,
            self.column
        );
        Token {
            token_type,
            line: self.line,
            column: self.column,
        }
    }
}

 File path: ./src/log.rs 
 
use std::fmt::Display;
use std::sync::atomic::{AtomicUsize, Ordering};

// ANSI color codes
pub const RED: &str = "\x1b[31m";
pub const YELLOW: &str = "\x1b[33m";
pub const GREEN: &str = "\x1b[32m";
pub const BLUE: &str = "\x1b[34m";
pub const MAGENTA: &str = "\x1b[35m";
pub const CYAN: &str = "\x1b[36m";
pub const RESET: &str = "\x1b[0m";
pub const BOLD: &str = "\x1b[1m";

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum LogLevel {
    Off,
    Error,
    Warning,
    Info,
    Debug,
    Trace,
}

static CURRENT_LOG_LEVEL: AtomicUsize = AtomicUsize::new(LogLevel::Info as usize);

pub fn set_log_level(level: LogLevel) {
    CURRENT_LOG_LEVEL.store(level as usize, Ordering::SeqCst);
}

pub fn get_log_level() -> LogLevel {
    match CURRENT_LOG_LEVEL.load(Ordering::SeqCst) {
        0 => LogLevel::Off,
        1 => LogLevel::Error,
        2 => LogLevel::Warning,
        3 => LogLevel::Info,
        4 => LogLevel::Debug,
        _ => LogLevel::Trace,
    }
}

pub fn is_enabled(level: LogLevel) -> bool {
    level as usize <= CURRENT_LOG_LEVEL.load(Ordering::SeqCst)
}

fn log_message(level: LogLevel, component: &str, message: &str) {
    if !is_enabled(level) {
        return;
    }

    let (level_name, color) = match level {
        LogLevel::Off => unreachable!(),
        LogLevel::Error => ("ERROR", RED),
        LogLevel::Warning => ("WARN ", YELLOW),
        LogLevel::Info => ("INFO ", GREEN),
        LogLevel::Debug => ("DEBUG", BLUE),
        LogLevel::Trace => ("TRACE", MAGENTA),
    };

    eprintln!(
        "{}{}[{}]{} {}{}[{}]{} {}",
        color, BOLD, level_name, RESET, CYAN, BOLD, component, RESET, message
    );
}

pub fn error(component: &str, message: impl Display) {
    log_message(LogLevel::Error, component, &format!("{message}"));
}

pub fn warn(component: &str, message: impl Display) {
    log_message(LogLevel::Warning, component, &format!("{message}"));
}

pub fn info(component: &str, message: impl Display) {
    log_message(LogLevel::Info, component, &format!("{message}"));
}

pub fn debug(component: &str, message: impl Display) {
    log_message(LogLevel::Debug, component, &format!("{message}"));
}

pub fn trace(component: &str, message: impl Display) {
    log_message(LogLevel::Trace, component, &format!("{message}"));
}

#[macro_export]
macro_rules! log_if {
    ($level:expr, $component:expr, $($arg:tt)*) => {
        if $crate::log::is_enabled($level) {
            let message = format!($($arg)*);
            match $level {
                $crate::log::LogLevel::Error => $crate::log::error($component, message),
                $crate::log::LogLevel::Warning => $crate::log::warn($component, message),
                $crate::log::LogLevel::Info => $crate::log::info($component, message),
                $crate::log::LogLevel::Debug => $crate::log::debug($component, message),
                $crate::log::LogLevel::Trace => $crate::log::trace($component, message),
                _ => {},
            }
        }
    };
}

#[macro_export]
macro_rules! error {
    ($component:expr, $($arg:tt)*) => {
        $crate::log_if!($crate::log::LogLevel::Error, $component, $($arg)*)
    };
}

#[macro_export]
macro_rules! warn {
    ($component:expr, $($arg:tt)*) => {
        $crate::log_if!($crate::log::LogLevel::Warning, $component, $($arg)*)
    };
}

#[macro_export]
macro_rules! info {
    ($component:expr, $($arg:tt)*) => {
        $crate::log_if!($crate::log::LogLevel::Info, $component, $($arg)*)
    };
}

#[macro_export]
macro_rules! debug {
    ($component:expr, $($arg:tt)*) => {
        $crate::log_if!($crate::log::LogLevel::Debug, $component, $($arg)*)
    };
}

#[macro_export]
macro_rules! trace {
    ($component:expr, $($arg:tt)*) => {
        $crate::log_if!($crate::log::LogLevel::Trace, $component, $($arg)*)
    };
}

 File path: ./src/ast_node.rs 
 
use std::fmt::Display;

use crate::tokens::Token;

#[derive(Debug)]
pub enum Expr {
    Binary {
        left: Box<Expr>,
        operator: Token,
        right: Box<Expr>,
    },
    Unary {
        operator: Token,
        right: Box<Expr>,
    },
    Grouping {
        expression: Box<Expr>,
    },
    Literal {
        value: LiteralValue,
    },
    Variable {
        name: Token,
    },
}

#[derive(Debug, Clone)]
pub enum LiteralValue {
    Number(f64),
    Bool(bool),
    String(String),
    Nil,
}
impl PartialOrd for LiteralValue {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        match (self, other) {
            (LiteralValue::Number(num1), LiteralValue::Number(num2)) => num1.partial_cmp(num2),
            (LiteralValue::String(str1), LiteralValue::String(str2)) => str1.partial_cmp(str2),
            (LiteralValue::Bool(bool1), LiteralValue::Bool(bool2)) => bool1.partial_cmp(bool2),
            (LiteralValue::Nil, LiteralValue::Nil) => Some(std::cmp::Ordering::Equal),

            _ => None,
        }
    }
}

impl PartialEq for LiteralValue {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (LiteralValue::Number(num1), LiteralValue::Number(num2)) => num1 == num2,
            (LiteralValue::String(str1), LiteralValue::String(str2)) => str1 == str2,
            (LiteralValue::Bool(bool1), LiteralValue::Bool(bool2)) => bool1 == bool2,
            (LiteralValue::Nil, LiteralValue::Nil) => true,
            _ => false,
        }
    }
    fn ne(&self, other: &Self) -> bool {
        match (self, other) {
            (LiteralValue::Number(num1), LiteralValue::Number(num2)) => num1 != num2,
            (LiteralValue::String(str1), LiteralValue::String(str2)) => str1 != str2,
            (LiteralValue::Bool(bool1), LiteralValue::Bool(bool2)) => bool1 != bool2,
            (LiteralValue::Nil, LiteralValue::Nil) => false,
            _ => true,
        }
    }
}

impl Display for LiteralValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Bool(b) => write!(f, "{b}"),
            Self::Number(n) => write!(f, "{n}"),
            Self::Nil => write!(f, "Nil"),
            Self::String(s) => write!(f, "{s}"),
        }
    }
}

#[derive(Debug)]
pub enum Stmt {
    Expression {
        expression: Expr,
    },
    If {
        condition: Expr,
        then_branch: Box<Stmt>,
        else_branch: Option<Box<Stmt>>,
    },
    Echo {
        expression: Expr,
    },
    Block {
        statements: Vec<Stmt>,
    },
    FunctionDeclaration {
        args: Vec<Expr>,
        name: String,
        body: Box<Stmt>,
    },
    Let {
        name: Token,
        initializer: Option<Expr>,
    },
}

 File path: ./src/parser.rs 
 
use crate::ast_node::*;
use crate::tokens::*;
use crate::{debug, error, info, trace, warn};

pub struct Parser {
    tokens: Vec<Token>,
    current: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        info!("Parser", "Creating new parser with {} tokens", tokens.len());
        Parser { tokens, current: 0 }
    }

    pub fn parse(&mut self) -> Result<Vec<Stmt>, String> {
        info!("Parser", "Starting parsing");
        let mut statements = Vec::new();

        while !self.is_at_end() {
            trace!(
                "Parser",
                "Parsing statement at token index {}",
                self.current
            );
            match self.statement() {
                Ok(stmt) => {
                    debug!("Parser", "Successfully parsed statement: {:?}", stmt);
                    statements.push(stmt);
                }
                Err(error) => {
                    error!("Parser", "Failed to parse statement: {}", error);
                    return Err(error);
                }
            }
        }

        info!(
            "Parser",
            "Parsing complete, found {} statements",
            statements.len()
        );
        Ok(statements)
    }

    fn statement(&mut self) -> Result<Stmt, String> {
        let token = self.peek();
        trace!(
            "Parser",
            "Determining statement type from token: {:?}",
            token.token_type
        );

        match &token.token_type {
            TokenType::Let => {
                debug!("Parser", "Parsing let statement at line {}", token.line);
                self.advance();
                self.let_statement()
            }
            TokenType::If => {
                debug!("Parser", "Parsing if statement at line {}", token.line);
                self.advance();
                self.if_statement()
            }
            TokenType::Echo => {
                debug!("Parser", "Parsing echo statement at line {}", token.line);
                self.advance();
                self.echo_statement()
            }
            TokenType::FunctionDeclaration => {
                debug!(
                    "Parser",
                    "Parsing function declaration at line {}", token.line
                );
                self.advance();
                self.function_declaration()
            }
            _ => {
                debug!(
                    "Parser",
                    "Parsing expression statement at line {}", token.line
                );
                self.expression_statement()
            }
        }
    }

    fn function_declaration(&mut self) -> Result<Stmt, String> {
        trace!("Parser", "Looking for function name");

        let function_name = match self.consume_advance_if(
            |t| matches!(t, TokenType::Identifier(_)),
            "Expected function name",
        ) {
            Ok(Token {
                token_type: TokenType::Identifier(name),
                ..
            }) => {
                debug!("Parser", "Found function name: {}", name);
                name
            }
            Ok(_) => {
                error!(
                    "Parser",
                    "Expected identifier token for function name, but got something else"
                );
                return Err(String::from("Expected function name"));
            }
            Err(e) => {
                error!("Parser", "Failed to get function name: {}", e);
                return Err(e);
            }
        };

        trace!("Parser", "Looking for left parenthesis");
        if self.match_token(TokenType::LeftParen) {
            debug!("Parser", "Parsing function arguments");
            let mut args = Vec::new();

            while !self.match_token(TokenType::RightParen) {
                trace!("Parser", "Parsing function argument");
                let arg = match self.expression() {
                    Ok(expr) => {
                        debug!("Parser", "Added function argument: {:?}", expr);
                        expr
                    }
                    Err(e) => {
                        error!("Parser", "Failed to parse function argument: {}", e);
                        return Err(e);
                    }
                };
                args.push(arg);

                if !self.match_token(TokenType::Comma) {
                    trace!("Parser", "No more function arguments");
                    self.advance();
                    break;
                }
                trace!("Parser", "Found comma, expecting another argument");
            }
            debug!("Parser", "Function has {} arguments", args.len());

            trace!("Parser", "Looking for function body");
            if self.match_token(TokenType::LeftBrace) {
                debug!("Parser", "Parsing function body");
                let function_body = match self.block() {
                    Ok(body) => body,
                    Err(e) => {
                        error!("Parser", "Failed to parse function body: {}", e);
                        return Err(e);
                    }
                };

                debug!(
                    "Parser",
                    "Successfully parsed function declaration '{}'", function_name
                );
                return Ok(Stmt::FunctionDeclaration {
                    args,
                    name: function_name,
                    body: Box::new(function_body),
                });
            } else {
                error!("Parser", "Expected {{, found {:?}", self.peek());
                Err(String::from("Expected function body"))
            }
        } else {
            error!("Parser", "Expected (, found {:?}", self.peek());
            Err(String::from("Expected left paren"))
        }
    }

    fn let_statement(&mut self) -> Result<Stmt, String> {
        trace!("Parser", "Looking for variable name in let statement");
        let name = match self.consume_advance_if(
            |t| matches!(t, TokenType::Identifier(_)),
            "Expect variable name.",
        ) {
            Ok(token) => {
                if let TokenType::Identifier(ref name) = token.token_type {
                    debug!("Parser", "Found variable name: {}", name);
                    token
                } else {
                    error!(
                        "Parser",
                        "Unexpected token type after passing identifier check"
                    );
                    return Err(String::from("Expected variable name"));
                }
            }
            Err(e) => {
                error!("Parser", "Failed to get variable name: {}", e);
                return Err(e);
            }
        };

        let mut initializer = None;

        trace!("Parser", "Checking for variable initializer");
        if self.match_token(TokenType::Equal) {
            debug!("Parser", "Parsing variable initializer");
            initializer = match self.expression() {
                Ok(expr) => {
                    debug!("Parser", "Successfully parsed variable initializer");
                    Some(expr)
                }
                Err(e) => {
                    error!("Parser", "Failed to parse initializer: {}", e);
                    return Err(e);
                }
            };
        } else {
            debug!("Parser", "No initializer for variable");
        }

        let var_name = if let TokenType::Identifier(ref name) = name.token_type {
            name
        } else {
            "unknown"
        };
        debug!(
            "Parser",
            "Successfully parsed let statement for '{}'", var_name
        );
        Ok(Stmt::Let { name, initializer })
    }

    fn block(&mut self) -> Result<Stmt, String> {
        debug!("Parser", "Parsing block statement");
        let mut statements = Vec::new();

        while !self.is_at_end() && !self.check(|t| *t == TokenType::RightBrace) {
            trace!("Parser", "Parsing statement inside block");
            match self.statement() {
                Ok(stmt) => {
                    debug!("Parser", "Added statement to block");
                    statements.push(stmt);
                }
                Err(e) => {
                    error!("Parser", "Failed to parse statement in block: {}", e);
                    return Err(e);
                }
            }
        }

        trace!("Parser", "Looking for closing brace for block");
        match self.consume_advance_if(
            |t| *t == TokenType::RightBrace,
            "Expected '}' after a block",
        ) {
            Ok(_) => {
                debug!(
                    "Parser",
                    "Successfully parsed block with {} statements",
                    statements.len()
                );
                Ok(Stmt::Block { statements })
            }
            Err(e) => {
                error!("Parser", "Failed to find closing brace: {}", e);
                Err(e)
            }
        }
    }

    fn if_statement(&mut self) -> Result<Stmt, String> {
        debug!("Parser", "Parsing if statement condition");
        let condition = match self.expression() {
            Ok(expr) => {
                debug!("Parser", "Successfully parsed if condition");
                expr
            }
            Err(e) => {
                error!("Parser", "Failed to parse if condition: {}", e);
                return Err(e);
            }
        };

        trace!("Parser", "Looking for opening brace for if body");
        if self.match_token(TokenType::LeftBrace) {
            debug!("Parser", "Parsing if statement body");
            let then_branch = match self.block() {
                Ok(block) => {
                    debug!("Parser", "Successfully parsed if body");
                    block
                }
                Err(e) => {
                    error!("Parser", "Failed to parse if body: {}", e);
                    return Err(e);
                }
            };

            trace!("Parser", "Checking for else clause");
            if self.match_token(TokenType::Else) {
                debug!("Parser", "Parsing else clause");

                trace!("Parser", "Looking for opening brace for else body");
                if self.match_token(TokenType::LeftBrace) {
                    debug!("Parser", "Parsing else body");
                    let else_branch = match self.block() {
                        Ok(block) => {
                            debug!("Parser", "Successfully parsed else body");
                            block
                        }
                        Err(e) => {
                            error!("Parser", "Failed to parse else body: {}", e);
                            return Err(e);
                        }
                    };

                    debug!("Parser", "Successfully parsed complete if-else statement");
                    Ok(Stmt::If {
                        condition,
                        then_branch: Box::new(then_branch),
                        else_branch: Some(Box::new(else_branch)),
                    })
                } else {
                    error!("Parser", "Expected {{ after else, found {:?}", self.peek());
                    Err(String::from("Expected '{' after condition"))
                }
            } else {
                debug!("Parser", "Successfully parsed if statement without else");
                Ok(Stmt::If {
                    condition,
                    then_branch: Box::new(then_branch),
                    else_branch: None,
                })
            }
        } else {
            error!(
                "Parser",
                "Expected {{ after if condition, found {:?}",
                self.peek()
            );
            Err(String::from("Expected '{' after condition"))
        }
    }

    fn echo_statement(&mut self) -> Result<Stmt, String> {
        debug!("Parser", "Parsing echo statement expression");
        match self.expression() {
            Ok(expr) => {
                debug!("Parser", "Successfully parsed echo statement");
                Ok(Stmt::Echo { expression: expr })
            }
            Err(e) => {
                error!("Parser", "Failed to parse echo expression: {}", e);
                Err(e)
            }
        }
    }

    fn equality(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing equality expression");
        let mut expr = match self.comparison() {
            Ok(e) => e,
            Err(e) => {
                error!("Parser", "Failed to parse left side of equality: {}", e);
                return Err(e);
            }
        };

        while self.match_tokens(&[TokenType::EqualEqual, TokenType::BangEqual]) {
            let operator = self.previous().clone();
            trace!(
                "Parser",
                "Found equality operator: {:?}",
                operator.token_type
            );

            let right_expr = match self.term() {
                Ok(e) => e,
                Err(e) => {
                    error!("Parser", "Failed to parse right side of equality: {}", e);
                    return Err(e);
                }
            };

            trace!(
                "Parser",
                "Creating binary expression with operator {:?}",
                operator.token_type
            );
            expr = Expr::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right_expr),
            };
        }

        Ok(expr)
    }

    fn comparison(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing comparison expression");
        let mut expr = match self.term() {
            Ok(e) => e,
            Err(e) => {
                error!("Parser", "Failed to parse left side of comparison: {}", e);
                return Err(e);
            }
        };

        while self.match_tokens(&[
            TokenType::Greater,
            TokenType::GreaterOrEq,
            TokenType::Less,
            TokenType::LessOrEq,
        ]) {
            let operator = self.previous().clone();
            trace!(
                "Parser",
                "Found comparison operator: {:?}",
                operator.token_type
            );

            let right_expr = match self.term() {
                Ok(e) => e,
                Err(e) => {
                    error!("Parser", "Failed to parse right side of comparison: {}", e);
                    return Err(e);
                }
            };

            trace!(
                "Parser",
                "Creating binary expression with operator {:?}",
                operator.token_type
            );
            expr = Expr::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right_expr),
            }
        }

        Ok(expr)
    }

    fn expression_statement(&mut self) -> Result<Stmt, String> {
        debug!("Parser", "Parsing expression statement");
        match self.expression() {
            Ok(expr) => {
                debug!("Parser", "Successfully parsed expression statement");
                Ok(Stmt::Expression { expression: expr })
            }
            Err(e) => {
                error!("Parser", "Failed to parse expression statement: {}", e);
                Err(e)
            }
        }
    }

    fn expression(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing expression");
        self.equality()
    }

    fn term(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing term");
        let mut expr = match self.factor() {
            Ok(e) => e,
            Err(e) => {
                error!("Parser", "Failed to parse term: {}", e);
                return Err(e);
            }
        };

        while self.match_tokens(&[TokenType::Plus, TokenType::Minus]) {
            let operator = self.previous().clone();
            trace!("Parser", "Found term operator: {:?}", operator.token_type);

            let right = match self.factor() {
                Ok(e) => e,
                Err(e) => {
                    error!("Parser", "Failed to parse right side of term: {}", e);
                    return Err(e);
                }
            };

            trace!(
                "Parser",
                "Creating binary expression with operator {:?}",
                operator.token_type
            );
            expr = Expr::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }

        Ok(expr)
    }

    fn factor(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing factor");
        let mut expr = match self.unary() {
            Ok(e) => e,
            Err(e) => {
                error!("Parser", "Failed to parse factor: {}", e);
                return Err(e);
            }
        };

        while self.match_tokens(&[TokenType::Star, TokenType::Slash]) {
            let operator = self.previous().clone();
            trace!("Parser", "Found factor operator: {:?}", operator.token_type);

            let right = match self.unary() {
                Ok(e) => e,
                Err(e) => {
                    error!("Parser", "Failed to parse right side of factor: {}", e);
                    return Err(e);
                }
            };

            trace!(
                "Parser",
                "Creating binary expression with operator {:?}",
                operator.token_type
            );
            expr = Expr::Binary {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            };
        }

        Ok(expr)
    }

    fn unary(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing unary expression");

        if self.match_tokens(&[TokenType::Minus]) {
            let operator = self.previous().clone();
            trace!("Parser", "Found unary operator: {:?}", operator.token_type);

            let right = match self.unary() {
                Ok(e) => e,
                Err(e) => {
                    error!("Parser", "Failed to parse unary expression: {}", e);
                    return Err(e);
                }
            };

            trace!(
                "Parser",
                "Creating unary expression with operator {:?}",
                operator.token_type
            );
            return Ok(Expr::Unary {
                operator,
                right: Box::new(right),
            });
        }

        self.primary()
    }

    fn primary(&mut self) -> Result<Expr, String> {
        trace!("Parser", "Parsing primary expression");

        if self.match_token(TokenType::LeftParen) {
            debug!("Parser", "Parsing grouped expression");
            let expr = match self.expression() {
                Ok(e) => e,
                Err(e) => {
                    error!("Parser", "Failed to parse grouped expression: {}", e);
                    return Err(e);
                }
            };

            trace!("Parser", "Looking for closing parenthesis");
            match self.consume_advance_if(
                |t| *t == TokenType::RightParen,
                "Expect ')' after expression.",
            ) {
                Ok(_) => {
                    debug!("Parser", "Successfully parsed grouped expression");
                    return Ok(Expr::Grouping {
                        expression: Box::new(expr),
                    });
                }
                Err(e) => {
                    error!("Parser", "Failed to find closing parenthesis: {}", e);
                    return Err(e);
                }
            }
        }

        if let Ok(token) =
            self.consume_advance_if(|t| matches!(t, TokenType::Number(_)), "Expect expression.")
        {
            if let TokenType::Number(value) = token.token_type {
                debug!("Parser", "Parsed number literal: {}", value);
                return Ok(Expr::Literal {
                    value: LiteralValue::Number(value),
                });
            }
        }

        if let Ok(token) =
            self.consume_advance_if(|t| matches!(t, TokenType::Bool(_)), "Expect expression.")
        {
            if let TokenType::Bool(val) = token.token_type {
                debug!("Parser", "Parsed boolean literal: {}", val);
                return Ok(Expr::Literal {
                    value: LiteralValue::Bool(val),
                });
            }
        }

        if let Ok(token) =
            self.consume_advance_if(|t| matches!(t, TokenType::String(_)), "Expect expression.")
        {
            if let TokenType::String(val) = token.token_type {
                debug!("Parser", "Parsed string literal: \"{}\"", val);
                return Ok(Expr::Literal {
                    value: LiteralValue::String(val),
                });
            }
        }

        if let Ok(token) = self.consume_advance_if(
            |t| matches!(t, TokenType::Identifier(_)),
            "Expect expression.",
        ) {
            if let TokenType::Identifier(ref name) = token.token_type {
                debug!("Parser", "Parsed variable reference: {}", name);
            }
            return Ok(Expr::Variable { name: token });
        }

        error!(
            "Parser",
            "Unexpected token: {:?} at line {}, column {}",
            self.peek().token_type,
            self.peek().line,
            self.peek().column
        );
        Err(format!("Unexpected token: {:?}", self.peek()))
    }

    // Helper methods
    fn match_token(&mut self, token_type: TokenType) -> bool {
        trace!("Parser", "Matching against token type: {:?}", token_type);
        if self.check(|t| *t == token_type) {
            self.advance();
            trace!("Parser", "Token matched");
            true
        } else {
            trace!(
                "Parser",
                "Token did not match, found: {:?}",
                self.peek().token_type
            );
            false
        }
    }

    fn match_tokens(&mut self, token_types: &[TokenType]) -> bool {
        trace!("Parser", "Matching against multiple token types");
        for token_type in token_types {
            if self.check(|t| t == token_type) {
                self.advance();
                trace!("Parser", "Token matched: {:?}", token_type);
                return true;
            }
        }

        trace!(
            "Parser",
            "No token matched, found: {:?}",
            self.peek().token_type
        );
        false
    }

    /// Basically skips token if predicate is true
    /// If predicate returns true -> we skip to next token and return the old one.
    /// if returns false -> errors
    fn consume_advance_if<F>(&mut self, predicate: F, error_message: &str) -> Result<Token, String>
    where
        F: Fn(&TokenType) -> bool,
    {
        trace!(
            "Parser",
            "Advancing if predicate matches, current token: {:?}",
            self.peek().token_type
        );
        if self.check(&predicate) {
            let token = self.advance();
            trace!("Parser", "Token consumed: {:?}", token.token_type);
            Ok(token)
        } else {
            let err = format!("{} Got {:?}", error_message, self.peek());
            trace!("Parser", "Token consumption failed: {}", err);
            Err(err)
        }
    }

    fn check<F>(&self, predicate: F) -> bool
    where
        F: Fn(&TokenType) -> bool,
    {
        if self.is_at_end() {
            trace!("Parser", "Check failed: at end of input");
            false
        } else {
            predicate(&self.peek().token_type)
        }
    }

    fn advance(&mut self) -> Token {
        if !self.is_at_end() {
            self.current += 1;
            trace!(
                "Parser",
                "Advanced to token {}: {:?}",
                self.current - 1,
                self.previous().token_type
            );
        } else {
            trace!("Parser", "Attempted to advance past end of input");
        }

        self.previous().clone()
    }

    fn is_at_end(&self) -> bool {
        let at_end = matches!(self.peek().token_type, TokenType::EOF);
        at_end
    }

    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    fn previous(&self) -> &Token {
        &self.tokens[self.current - 1]
    }
}

 File path: ./src/tokens.rs 
 
use crate::ast_node::Expr;
pub struct FunctionCallData {
    args: Vec<Expr>,
}
#[derive(Debug, PartialEq, Clone)]
pub enum TokenType {
    // Literals
    Number(f64),
    Identifier(String),
    Bool(bool),
    String(String),

    // Operators
    Plus,
    Minus,
    Star,
    Slash,

    //comaprison
    Equal,
    BangEqual,
    EqualEqual,
    Greater,
    Less,
    GreaterOrEq,
    LessOrEq,

    //logical ops
    LogicalNot,

    // Delimiters
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    DoubleQuotes,

    FunctionDeclaration,
    FunctionCall,
    Comma,

    Let,
    If,
    Else,
    Echo,
    // Control
    EOF,
}

#[derive(Debug, Clone)]
pub struct Token {
    pub token_type: TokenType,
    pub line: usize,
    pub column: usize,
}

